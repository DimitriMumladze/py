# ============================================================================
# სავაჭრო ცენტრის მომხმარებლების კლასტერიზაციის ანალიზი
# ============================================================================
# ეს სკრიპტი აჩვენებს ზედამხედველობის გარეშე სწავლებას (კლასტერიზაციის) ტექნიკებს:
# 1. K-Means კლასტერიზაცია ვიზუალიზაციით
# 2. აგლომერაციული (იერარქიული) კლასტერიზაცია დენდროგრამით
# 3. სილუეტის ქულა კლასტერის ხარისხის შეფასებისთვის
# მონაცემთა ნაკრები: Mall_Customers.csv (მომხმარებლების სეგმენტაციის მონაცემები)
# ============================================================================

# საჭირო ბიბლიოთეკების შემოტანა
import pandas as pd  # მონაცემთა მანიპულაციისთვის
from sklearn.cluster import KMeans, AgglomerativeClustering  # კლასტერიზაციის ალგორითმები
from scipy.cluster.hierarchy import linkage, dendrogram  # იერარქიული კლასტერიზაციის ვიზუალიზაციისთვის
from sklearn.metrics import silhouette_score  # კლასტერის ხარისხის შესაფასებლად
import matplotlib.pyplot as plt  # ვიზუალიზაციების შესაქმნელად

# ============================================================================
# მონაცემების ჩატვირთვა და გამოკვლევა
# ============================================================================

# სავაჭრო ცენტრის მომხმარებლების მონაცემთა ნაკრების URL-დან ჩატვირთვა
data = pd.read_csv("https://gist.githubusercontent.com/pravalliyaram/5c05f43d2351249927b8a3f3cc3e5ecf/raw/8bd6144a87988213693754baaa13fb204933282d/Mall_Customers.csv")

# მონაცემთა ნაკრების ძირითადი ინფორმაციის ჩვენება
print("=" * 70)
print("სავაჭრო ცენტრის მომხმარებლების მონაცემთა ნაკრები")
print("=" * 70)
print("ორიგინალური მონაცემები:")
print(data.head())
print(f"\nმონაცემთა ნაკრების ფორმა: {data.shape}")
print(f"სვეტები: {list(data.columns)}")
print("\n")

# ============================================================================
# მონაცემების წინასწარი დამუშავება
# ============================================================================

# CustomerID და Age სვეტების წაშლა, რადგან ისინი ამ ანალიზისთვის არ არის საჭირო
# axis=1 ნიშნავს სვეტების წაშლას (არა მწკრივების)
# inplace=True პირდაპირ არედაქტირებს dataframe-ს
data.drop(['CustomerID', 'Age'], axis=1, inplace=True)

print("წინასწარი დამუშავების შემდეგ მონაცემები:")
print(data.head())
print("\n")

# ============================================================================
# გამოკვლევითი მონაცემთა ვიზუალიზაცია
# ============================================================================

print("=" * 70)
print("გამოკვლევითი მონაცემთა ანალიზი")
print("=" * 70)

# სკატერის დიაგრამის შექმნა შემოსავლისა და ხარჯვის ურთიერთობის ვიზუალიზაციისთვის
plt.figure(figsize=(10, 8))
plt.scatter(data['Annual Income (k$)'], data['Spending Score (1-100)'])
plt.xlabel('წლიური შემოსავალი (k$)')  # X-ღერძის ხელმოწერა
plt.ylabel('ხარჯვის ქულა (1-100)')  # Y-ღერძის ხელმოწერა
plt.title('მომხმარებლების განაწილება: შემოსავალი vs ხარჯვის ქულა')
plt.grid(True, alpha=0.3)  # ნაზი ბადის დამატება
plt.show()

# ============================================================================
# K-MEANS კლასტერიზაცია (5 კლასტერი)
# ============================================================================

print("=" * 70)
print("K-MEANS კლასტერიზაცია")
print("=" * 70)

# K-Means მოდელის შექმნა 5 კლასტერით
# n_clusters=5 ნიშნავს, რომ გვინდა მომხმარებლების 5 ჯგუფად დაყოფა
clustering_kmeans = KMeans(n_clusters=5)

# მოდელის მორგება და თითოეული მომხმარებლისთვის კლასტერის ლეიბლის პროგნოზირება
# ვიყენებთ მხოლოდ 'წლიური შემოსავალი' და 'ხარჯვის ქულა' სვეტებს
labels_kmeans = clustering_kmeans.fit_predict(data[['Annual Income (k$)', 'Spending Score (1-100)']])

# K-Means კლასტერიზაციის შედეგების ვიზუალიზაცია
plt.figure(figsize=(12, 8))

# თითოეული მომხმარებლის გამოსახვა მათი კლასტერის მიხედვით შეღებილი
plt.scatter(data['Annual Income (k$)'], data['Spending Score (1-100)'], c=labels_kmeans, cmap='viridis')

# კლასტერის ცენტრების ლურჯი წერტილებით გამოსახვა
# cluster_centers_[:,0] იღებს x-კოორდინატებს (შემოსავალი)
# cluster_centers_[:,1] იღებს y-კოორდინატებს (ხარჯვის ქულა)
plt.scatter(clustering_kmeans.cluster_centers_[:, 0], 
            clustering_kmeans.cluster_centers_[:, 1], 
            c='blue', s=200, marker='X', edgecolors='black', linewidths=2,
            label='კლასტერის ცენტრები')

# დამატებითი შეხედულებისთვის თითოეულ წერტილზე სქესის ლეიბლების დამატება
for i, gender in enumerate(data['Gender']):
    plt.annotate(text=gender, 
                xy=(data['Annual Income (k$)'][i], data['Spending Score (1-100)'][i]),
                fontsize=6, alpha=0.6)

plt.xlabel('წლიური შემოსავალი (k$)')
plt.ylabel('ხარჯვის ქულა (1-100)')
plt.title('K-Means კლასტერიზაცია: მომხმარებლების სეგმენტაცია (5 კლასტერი)')
plt.colorbar(label='კლასტერი')  # კლასტერის ნომრების ჩვენებისთვის ფერის ზოლის დამატება
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

# ინერციის ჩვენება (უახლოეს კლასტერის ცენტრამდე მანძილების კვადრატების ჯამი)
# დაბალი ინერცია ნიშნავს უფრო მჭიდრო კლასტერებს
print(f"K-Means ინერცია: {clustering_kmeans.inertia_:.2f}")
print("\n")

# ============================================================================
# K-MEANS 3 კლასტერით (ასაკი vs ხარჯვის ქულა)
# ============================================================================

print("=" * 70)
print("K-MEANS კლასტერიზაცია - ალტერნატივა (ასაკი vs ხარჯვა)")
print("=" * 70)

# ალტერნატიული კლასტერიზაციის მიდგომისთვის მონაცემების ხელახალი ჩატვირთვა
customer = pd.read_csv("https://gist.githubusercontent.com/pravalliyaram/5c05f43d2351249927b8a3f3cc3e5ecf/raw/8bd6144a87988213693754baaa13fb204933282d/Mall_Customers.csv")

# ამჯერად სხვა სვეტების წაშლა (ასაკის დატოვება, შემოსავლის წაშლა)
customer.drop(["CustomerID", "Annual Income (k$)"], axis=1, inplace=True)

# K-Means მოდელის შექმნა 3 კლასტერით
model_kmeans_3 = KMeans(n_clusters=3)

# კლასტერების მორგება და პროგნოზირება
color_predicted = model_kmeans_3.fit_predict(customer[["Age", "Spending Score (1-100)"]])

# შედეგების ვიზუალიზაცია
plt.figure(figsize=(10, 8))
plt.scatter(x=customer["Age"], y=customer["Spending Score (1-100)"], c=color_predicted, cmap='plasma')

# კლასტერის ცენტრების გამოსახვა
plt.scatter(x=model_kmeans_3.cluster_centers_[:, 0], 
            y=model_kmeans_3.cluster_centers_[:, 1], 
            c="red", s=200, marker='X', edgecolors='black', linewidths=2,
            label='კლასტერის ცენტრები')

plt.xlabel('ასაკი')
plt.ylabel('ხარჯვის ქულა (1-100)')
plt.title('K-Means კლასტერიზაცია: ასაკი vs ხარჯვის ქულა (3 კლასტერი)')
plt.colorbar(label='კლასტერი')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

print(f"K-Means (3 კლასტერი) ინერცია: {model_kmeans_3.inertia_:.2f}")
print("\n")

# ============================================================================
# იერარქიული (აგლომერაციული) კლასტერიზაცია დენდროგრამით
# ============================================================================

print("=" * 70)
print("იერარქიული კლასტერიზაცია")
print("=" * 70)

# დენდროგრამისთვის linkage მატრიცის შექმნა
# ეს ითვლის იერარქიული კლასტერიზაციის სტრუქტურას
z = linkage(customer[["Age", "Spending Score (1-100)"]])

# დენდროგრამის გამოსახვა იერარქიული კლასტერიზაციის ვიზუალიზაციისთვის
plt.figure(figsize=(15, 8))
dendrogram(z)  # დენდროგრამის დიაგრამის შექმნა
plt.xlabel('მომხმარებლის ინდექსი')
plt.ylabel('მანძილი')
plt.title('იერარქიული კლასტერიზაციის დენდროგრამა')
plt.axhline(y=200, color='r', linestyle='--', label='ჭრის ხაზი 5 კლასტერისთვის')  # შემოთავაზებული ჭრის ხაზი
plt.legend()
plt.show()

# აგლომერაციული კლასტერიზაციის მოდელის შექმნა 5 კლასტერით
# linkage='ward' ამცირებს კლასტერებში დისპერსიას
model_agg = AgglomerativeClustering(n_clusters=5, linkage="ward")

# კლასტერის ლეიბლების მორგება და პროგნოზირება
label_agg = model_agg.fit_predict(customer[["Age", "Spending Score (1-100)"]])

# სილუეტის ქულის გამოთვლისთვის მონაცემების მომზადება
x = customer[["Age", "Spending Score (1-100)"]]

# სილუეტის ქულის გამოთვლა (ზომავს კლასტერის ხარისხს)
# ქულა მერყეობს -1-დან 1-მდე, სადაც უფრო მაღალი უკეთესია
# 0-თან ახლოს მნიშვნელობები მიუთითებს გადახურულ კლასტერებზე
silhouette = silhouette_score(x, label_agg)

print(f"აგლომერაციული კლასტერიზაციის სილუეტის ქულა: {silhouette:.4f}")
print("ინტერპრეტაცია: უფრო მაღალი ქულა (1-თან ახლოს) ნიშნავს უკეთესად განსაზღვრულ კლასტერებს")
print("\n")

# აგლომერაციული კლასტერიზაციის შედეგების ვიზუალიზაცია
plt.figure(figsize=(10, 8))
plt.scatter(x=customer["Age"], y=customer["Spending Score (1-100)"], c=label_agg, cmap='coolwarm')
plt.xlabel('ასაკი')
plt.ylabel('ხარჯვის ქულა (1-100)')
plt.title('აგლომერაციული კლასტერიზაცია: ასაკი vs ხარჯვის ქულა (5 კლასტერი)')
plt.colorbar(label='კლასტერი')
plt.grid(True, alpha=0.3)
plt.show()

# ============================================================================
# შეჯამება
# ============================================================================

print("=" * 70)
print("კლასტერიზაციის ანალიზის შეჯამება")
print("=" * 70)
print(f"K-Means (5 კლასტერი) ინერცია: {clustering_kmeans.inertia_:.2f}")
print(f"K-Means (3 კლასტერი) ინერცია: {model_kmeans_3.inertia_:.2f}")
print(f"აგლომერაციული კლასტერიზაციის სილუეტის ქულა: {silhouette:.4f}")
print("\nშენიშვნა: დაბალი ინერცია = უფრო მჭიდრო კლასტერები")
print("      უფრო მაღალი სილუეტის ქულა = უკეთესი კლასტერების განცალკევება")
print("=" * 70)
